{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/seed-engine/src/Engine.js","webpack:///./node_modules/seed-engine/src/base/Updateable.js","webpack:///./node_modules/seed-engine/src/component/Audio.js","webpack:///./node_modules/seed-engine/src/component/BoxCollider.js","webpack:///./node_modules/seed-engine/src/component/CircleCollider.js","webpack:///./node_modules/seed-engine/src/component/Collider.js","webpack:///./node_modules/seed-engine/src/component/Collider2D.js","webpack:///./node_modules/seed-engine/src/component/Component.js","webpack:///./node_modules/seed-engine/src/component/Physics.js","webpack:///./node_modules/seed-engine/src/component/Physics2D.js","webpack:///./node_modules/seed-engine/src/component/Renderable.js","webpack:///./node_modules/seed-engine/src/component/Renderable2D.js","webpack:///./node_modules/seed-engine/src/component/RenderableSquare.js","webpack:///./node_modules/seed-engine/src/component/Transform.js","webpack:///./node_modules/seed-engine/src/const/FragmentShader.js","webpack:///./node_modules/seed-engine/src/const/VertexShader.js","webpack:///./node_modules/seed-engine/src/entry.js","webpack:///./node_modules/seed-engine/src/internal/Bounds.js","webpack:///./node_modules/seed-engine/src/internal/Color.js","webpack:///./node_modules/seed-engine/src/internal/Point.js","webpack:///./node_modules/seed-engine/src/manager/AudioManager.js","webpack:///./node_modules/seed-engine/src/manager/DOMManager.js","webpack:///./node_modules/seed-engine/src/manager/EngineManager.js","webpack:///./node_modules/seed-engine/src/manager/InputManager.js","webpack:///./node_modules/seed-engine/src/manager/Manager.js","webpack:///./node_modules/seed-engine/src/manager/NetworkManager.js","webpack:///./node_modules/seed-engine/src/manager/PersistentManager.js","webpack:///./node_modules/seed-engine/src/manager/PhysicsManager.js","webpack:///./node_modules/seed-engine/src/manager/ProgramManager.js","webpack:///./node_modules/seed-engine/src/manager/RenderManager.js","webpack:///./node_modules/seed-engine/src/manager/SceneManager.js","webpack:///./node_modules/seed-engine/src/manager/UpdateableManager.js","webpack:///./node_modules/seed-engine/src/object/GameObject.js","webpack:///./node_modules/seed-engine/src/object/PersistentObject.js","webpack:///./node_modules/seed-engine/src/object/SceneObject.js","webpack:///./node_modules/seed-engine/src/render/Viewport.js","webpack:///./node_modules/seed-engine/src/render/WebGL/Matrix.js","webpack:///./node_modules/seed-engine/src/render/WebGL/Matrix3.js","webpack:///./node_modules/seed-engine/src/scene/BasicScene.js","webpack:///./node_modules/seed-engine/src/scene/Scene.js","webpack:///./node_modules/seed-engine/src/utils/MathUtil.js","webpack:///./src/component/RandomMovement.js","webpack:///./src/entry.js","webpack:///./src/object/Player.js","webpack:///./src/scene/MainScene.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;AClFA;AAAA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uE;;;;;;;;;;;;;;;ACjDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;AC3GA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;;;;ACVA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;;;;ACXA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;;;;ACXA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;;;;ACVA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;;;;ACVA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACzBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;;;;ACfA;;AAEA;;AAEA,C;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,+DAA+D;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;AC3HA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACZA;;AAEA;;AAEA,C;;;;;;;;;;;;;;;;ACJA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;ACtLA;AAAA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,E;;;;;;;;;;;;;ACfA;AAAA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AA2CA;;;;;;;;;;;;;;;;;;;ACvGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;AC3CA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;ACzDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;AC9BA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6E;;;;;;;;;;;;;;;ACbA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2E;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8E;;;;;;;;;;;;;;;AC5FA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yC;AACA,6E;;;;;;;;;;;;;ACbA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACnBA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+E;;;;;;;;;;;;;;;ACbA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kF;;;;;;;;;;;;;;;ACzEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+E;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,eAAe,uBAAuB;AACtC;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+E;;;;;;;;;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,4BAA4B,4BAA4B;AACxD;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8E;;;;;;;;;;;;;;;;ACtGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6E;;;;;;;;;;;;;;;AC9HA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kF;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,uBAAuB,iDAAiD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,uBAAuB,2CAA2C;AAClE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,cAAc;AAC3E;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA,4BAA4B,2CAA2C;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;ACpLA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;ACtBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,C;;;;;;;;;;;;;;;;ACjBA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;AC3GA;AACmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;ACfA;AACsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;ACzEA;AAAA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,C;;;;;;;;;;;;;;;AChB+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;ACvCyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mB;;;;;;;;;;;;;;;;ACrBqD;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;ACjCmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,C","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/entry.js\");\n","'use-strict';\n\nimport EngineManager from './manager/EngineManager';\nimport Manager from './manager/Manager';\n\n/**\n * Engine Singleton class. Entry point reference to access managers and\n * to start and stop the Engine.\n */\nexport class _Engine {\n    /**\n     * Engine Contstructor.\n     */\n    constructor() {\n    }\n\n    /**\n     * Starts the engine.\n     */\n    start() {\n        EngineManager.start();\n    }\n\n    /**\n     * Stops the engine and cleans up code.\n     */\n    end() {\n        EngineManager.end();\n    }\n\n    /**\n     * Pauses the entire engine.\n     */\n    pause() {\n        EngineManager.pause();\n    }\n\n    /**\n     * Resumes to the Engine.\n     */\n    unpause() {\n        EngineManager.unpause();\n    }\n}\n\n/**\n * Singleton reference to the Engine.\n */\nconst Engine = new _Engine();\nexport default Engine;","import UpdateableManager from '../manager/UpdateableManager';\n\n/**\n * Baseclass for objects that follow the same ECS pattern of the seed engine.\n * \n * Used in anything that should follow a create, update, end loop \n * handled by the Engine.\n * \n * Many things will need to update/start/end. If you derive something that\n * has the start()/update()/end()... functions, the children should fill in\n * their respective callbacks (onStart()/onUpdate()/onEnd()/...).\n */\nexport default class Updateable {\n    constructor() {\n        this.hasStarted = false;\n        this.hasPaused = false;\n        this.id = -1;\n        this.deregister = UpdateableManager.registerUpdateable(this);\n    }\n\n    /**\n     * Base call function for when this Updateable is to be started.\n     */\n    start() {\n        this.onStart();\n        this.hasStarted = true;\n        this.update = this.postStartUpdate;\n    }\n\n    /**\n     * Base call function for when this Updateable is to be updated.\n     */\n    update() {\n        if (this.hasPaused)\n            return;\n            \n        this.start();\n    }\n\n    postStartUpdate() {\n        if (this.hasPaused)\n            return;\n\n        this.onUpdate();\n    }\n\n    /**\n     * Base call function for when this Updateable is to be ended.\n     */\n    end() {\n        this.onEnd();\n        this.destructor();\n    }\n\n    /**\n     * Base call function for when this Updateable is to be paused.\n     */\n    pause() {\n        if (!this.hasPaused) {\n            this.onPause();\n            this.hasPaused = true;\n        }\n    }\n\n    /**\n     * Base call function for when this Updateable is to be unpaused.\n     */\n    unpause() {\n        if (this.hasPaused) {\n            this.onUnpause();\n            this.hasPaused = false;\n        }\n    }\n\n    /**\n     * Cleanup code for when destroying an Updateable.\n     */\n    destructor() {\n        this.deregister();\n    }\n\n    /**\n     * Called when the the object is first introduced.\n     * \n     * Managing code will call this on first iteration once introduced to the game loop.\n     */\n    onStart() {}\n\n    /**\n     * Called on every update within the game, once the object has had onStart called.\n     */\n    onUpdate() {}\n\n    /**\n     * Called when the object is being removed or cleaned up from usage.\n     */\n    onEnd() {}\n\n    /**\n     * Called when the object is intended to be paused.\n     */\n    onPause() {}\n\n    /**\n     * Called when the object is to be unpaused from paused state.\n     */\n    onUnpause() {}\n}","import Component from './Component';\n\n/**\n * A Component that can be attatched to any GameObject.\n * \n * The Audio Component has controls for playing sounds and music.\n * Audio can be locallized to the Object location it is attached to.\n */\nexport default class Audio extends Component {\n\n}","import Collider2D from './Collider2D';\n\n/**\n * A 2D Collider Component which can be attached to any GameObject.\n * \n * A BoxCollider Component monitors collisions with other Collider Components. \n * \n * This component is refined to a 2D square.\n */\nexport default class BoxCollider extends Collider2D {\n\n}","import Collider2D from './Collider2D';\n\n/**\n * A 2D Collider Component which can be attached to any GameObject.\n * \n * A CircleCollider Component monitors collisions with other Collider Components. \n * \n * This component is refined to a 2D circle. A point of origin and radius.\n */\nexport default class CircleCollider extends Collider2D {\n\n}","import Component from './Component';\n\n/**\n * A Collider Component that checks bounds for collisions.\n * \n * This commponent has interface functions for calculating collisions\n * which have to be defined to work. See Subclasses.\n */\nexport default class Collider extends Component {\n\n}","import Collider from './Collider';\n\n/**\n * A Collider Component that checks bounds only on a plane.\n * \n * This commponent has interface functions for calculating collisions\n * which have to be defined to work. See Subclasses.\n */\nexport default class Collider2D extends Collider {\n\n}","import Updateable from '../base/Updateable';\n\n/**\n * A component may be added to any GameObject by using\n * GameObject's function: addComponent(component).\n * \n * A component should redefine the Updateable functions inherited with custom code to define the Component functionality.\n */\nexport default class Component extends Updateable {\n    /**\n     * Constructor for Base Components.\n     * Requires a boolean to indicate if a GameObject can contain multiple\n     * components of this type.\n     * \n     * @param {boolean} unique Is there only one of these component allowed on a GameObject?\n     */\n    constructor(unique) {\n        super();\n        this.isUnique = unique;\n    }\n\n    /**\n     * Called when the component is successfully added to a GameObject.\n     */\n    onAddComponent() {}\n}","import Component from './Component';\n\n/**\n * A Physics Component can be added to any GameObject and will give it\n * physical properties which can be toggled and adjusted.\n * \n * This Component should have nothing to do with collisions. Instead, Physics\n * should provide pre and post reactions to collisions, gravity, frictions,\n * and anything else that should respond to an effect or change.\n * \n * This is intended to be a base class for more specific physics handling\n * depending on the application.\n */\nexport default class Physics extends Component {\n    \n}","import Physics from './Physics';\n\nexport default class Physics2D extends Physics {\n\n}","import Component from './Component';\nimport SceneManager from '../manager/SceneManager';\nimport RenderManager from '../manager/RenderManager';\nimport ProgramManager from '../manager/ProgramManager';\nimport Matrix3 from '../render/WebGL/Matrix3';\nimport Color from '../internal/Color';\n\n/**\n * Base Renderable Component for all Components that want to draw to the screen. If\n * you want to show something on screen, it should derive Renderable.\n * \n * Contained in the class are functions for attaching the Renderable to viewports,\n * and updating Transform data into matricies for use with the Render Manager.\n * \n * The Renderable Component contains data on how the Renderable expects to be rendered.\n * Programs, render vectors, shader data, and other data that is on a per-object basis\n * for rendering is defined here.\n * \n * Classes which derive a Renderable should handle all base data and add or modify data\n * as needed to achieve certain effects.\n */\nexport default class Renderable extends Component {\n    /**\n     * Constructor for the Renderable component. Allows defaults to be assigned without\n     * having to call setter functions later.\n     * \n     * @param {Program} program A Program Object from the ProgramManager.\n     */\n    constructor(program = ProgramManager.getProgram('Default')) {\n        super(true);\n        this.deregisterViewports = {};\n\n        //currently unused\n        this.program = program;\n        this._matrixPosition = new Matrix3();\n        this._matrixScale = new Matrix3();\n        this._matrixRotation = new Matrix3();\n        this._matrixOriginOffset = new Matrix3();\n        this.color = new Color();\n        this.renderPositions = [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1];\n        this.primitiveType = RenderManager.GL.TRIANGLES;\n        this.primitiveCount = 6;\n    }\n\n    /**\n     * Returns a joined matrix of position, scale, rotation and origin adjustment.\n     */\n    getMatrix() {       \n        return Matrix3.copy(this._matrixPosition).multiply(this._matrixRotation).multiply(this._matrixScale).multiply(this._matrixOriginOffset);\n    }\n\n    /**\n     * Sets the position matrix to the new position point assigned.\n     * \n     * @param {Point} point A position point.\n     */\n    setPosition(point) {\n        this._matrixPosition.setPosition(point.x, point.y); //point.z if we had 3D to override this\n    }\n\n    /**\n     * Sets the origin offset matrix to the new position point assigned. This matrix reacts differently from other matrix\n     * assignment. 0,0 is regular top left corner origin, -0.5, -0.5 centers the origin to the center of the Transform, and\n     * -1, -1 will align the origin to the bottom right.\n     * \n     * @param {Point} point Origin offset point.\n     */\n    setOriginOffset(point) {\n        this._matrixOriginOffset.setPosition(point.x, point.y); //point.z if we had 3D to override this\n    }\n\n    /**\n     * Sets the rotation matrix to the new rotation value assigned.\n     * \n     * TODO: Change to a rotation point for x, y, z rotation instead of just z.\n     * \n     * @param {number} rotation A rotation in degrees.\n     */\n    setRotation(rotation) {\n        this._matrixRotation.setRotation(rotation);\n    }\n\n    /**\n     * Sets the scale matrix to the new scale point assigned.\n     * \n     * @param {Point} scale A scale point.\n     */\n    setScale(scale) {\n        this._matrixScale.setScale(scale.x, scale.y);\n    }\n\n    /**\n     * Called immediatly after the Render component is added to a game object.\n     * \n     * Updates the data of this renderable to the current Transform data.\n     */\n    onAddComponent() {\n        let transform = this.gameObject.getComponent(\"Transform\");\n        transform.renderable = this;\n        this.setPosition(transform.getPosition());\n        this.setScale(transform.getScale());\n        this.setRotation(transform.getRotation());\n    }\n\n    /**\n     * Adds this component to another viewport to be drawn. \n     * \n     * @param {number} viewportID Object ID of the viewport.\n     */\n    addToViewport(viewportID) {\n        this.deregisterViewports[viewportID] = SceneManager.getCurrentScene().registerRenderableComponent(this, viewportID);\n        return this;\n    }\n\n    /**\n     * Removes the renderable from all viewports.\n     */\n    removeFromViewports() {\n        let objKeys = Object.keys(this.deregisterViewports);\n        for (let i = 0; i < objKeys.length; i++) {\n            this.deregisterViewports[objKeys[i]]();\n        }\n    }\n}","import Renderable from './Renderable';\nimport Matrix3 from '../render/WebGL/Matrix3';\n\n/**\n * Renderable2D is a renderable component which focusses on\n * 2D shaders and matricies for 2D space rendering.\n */\nexport default class Renderable2D extends Renderable {\n    constructor() {\n        super();\n        this.className = 'Renderable2D';\n    }\n}","import Renderable2D from './Renderable2D';\n\nexport default class RenderableSquare extends Renderable2D {\n    \n}","import Component from './Component';\nimport Point from '../internal/Point';\n\n/**\n * A component all GameObjects are given by default on instantiation.\n * \n * Transform components are unique to the object, meaning there cannot be more than\n * one Transform on a GameObject.\n * \n * Transforms keep track of GameObject position, scale (size), rotation, and \n * origin offset. These should be changes with their respective setters, and not directly,\n * to ensure the correct components are notified of these changes.\n * \n * TODO: Make rotation work on 3 axis like position and scale.\n * TODO: Change the updates and setters of the position/scale/rotation to use funcions in their base\n * definitions and remove the wrappers here to reduce code.\n */\nexport default class Transform extends Component {\n    constructor(position = new Point(0, 0, 0), scale = new Point(1, 1, 1), rotation = 0) {\n        super(true);\n        this.className='Transform';\n        this._position = position;\n        this._rotation = rotation;\n        this._scale = scale;\n        this._originOffset = new Point(0, 0, 0);\n        this.renderable = null;\n    }\n\n    /**\n     * Sets the Transforms position.\n     * \n     * @param {number} x X position. Defaults to current X position.\n     * @param {number} y Y position. Defaults to current Y position.\n     * @param {number} z Z position. Defaults to current Z position.\n     */\n    setPosition(x = this._position.x, y = this._position.y, z = this._position.z) {\n        this._position.set(x, y, z);\n        if (this.renderable != null) {\n            this.renderable.setPosition(this._position);\n        }\n    }\n\n    /**\n     * Triggers between two types of regularly used origin points. \n     * \n     * Origin points are used with Renderables and other components to offset the origin different from the Transform's position.\n     * \n     * \"Center\": (-0.5, -0.5, -0.5) centered to the Tranform's position, and \"Default\": (0, 0, 0), beginning at the top left of the Transform.\n     * \n     * @param {boolean} center \"Center\" if true, \"Default\" if false.\n     */\n    centerOrigin(center = true) {\n        if (center) {\n            this.setOriginOffset(-0.5, -0.5, -0.5);\n        } else {\n            this.setOriginOffset(0, 0, 0);\n        }\n    }\n\n    /**\n     * Sets the origin offset position. \n     * \n     * If you want an object to exist at a \n     * position, but do something else (like drawing, animations) \n     * in a relative position the the Tranform, use this to change the \n     * offset from the Transfrom.\n     * \n     * (0, 0, 0) would be top left of the transform. \n     * (-0.5, -0.5, -0.5) would be center of the transform. \n     * (-1, -1, -1) would be bottom right of transform.\n     * \n     * Parameters default to their current values.\n     * \n     * @param {number} x X axis offset. Defaults to current origin offset X.\n     * @param {number} y Y axis offset. Defaults to current origin offset Y.\n     * @param {number} z Z axis offset. Defaults to current origin offset Z.\n     */\n    setOriginOffset(x = this._originOffset.x, y = this._originOffset.y, z = this._originOffset.z) {\n        this._originOffset.set(x, y, z);\n        if (this.renderable != null) {\n            this.renderable.setOriginOffset(this._originOffset);\n        }\n    }\n\n    /**\n     * Rotates the transform to face a different direction.\n     * \n     * TODO: implement more than z axis rotation.\n     * \n     * @param {number} rotation Rotation around the Z axis (in degrees).\n     */\n    setRotation(rotation) {\n        this._rotation = rotation;\n        if (this.renderable != null) {\n            this.renderable.setRotation(this._rotation);\n        }\n    }\n\n    /**\n     * \n     * @param {number} scaleX X scale from 1. Defaults to current scale X.\n     * @param {number} scaleY Y scale from 1. Defaults to current scale Y.\n     * @param {number} scaleZ Z scale from 1. Defaults to current scale Z.\n     */\n    setScale(scaleX = this.scaleX, scaleY = this.scaleY, scaleZ = this.scaleZ) {\n        this._scale.set(scaleX, scaleY, scaleZ);\n        if (this.renderable != null) {\n            this.renderable.setScale(this._scale);\n        }\n    }\n\n    /**\n     * Adds the parameters of this function to the Transforms position.\n     * \n     * @param {number} x X position. Defaults to 0.\n     * @param {number} y Y position. Defaults to 0.\n     * @param {number} z Z position. Defaults to 0.\n     */\n    translate(x = 0, y = 0, z = 0) {\n        this._position.x += x;\n        this._position.y += y;\n        this._position.z += z;\n        if (this.renderable != null) {\n            this.renderable.setPosition(this._position);\n        }\n    }\n\n    /**\n     * Adds the rotation parameter to the current Transform rotation.\n     * \n     * @param {number} rotation Rotation to add.\n     */\n    rotate(rotation) {\n        this._rotation += rotation;\n        if (this.renderable != null) {\n            this.renderable.setRotation(this._rotation);\n        }\n    }\n\n    /**\n     * Adds the parameters of this function to the Transforms scale.\n     * \n     * @param {number} scaleX X scale. Defaults to 0.\n     * @param {number} scaleY Y scale. Defaults to 0.\n     * @param {number} scaleZ Z scale. Defaults to 0.\n     */\n    scale(scaleX = 0, scaleY = 0, scaleZ = 0) {\n        this._scale.x += scaleX;\n        this._scale.y += scaleY;\n        this._scale.z += scaleZ;\n        if (this.renderable != null) {\n            this.renderable.setScale(this._scale);\n        }\n    }\n\n    /**\n     * @returns {Point} The transform's position.\n     */\n    getPosition() {\n        return this._position;\n    }\n\n    /**\n     * @returns {Point} The transform's scale.\n     */\n    getScale() {\n        return this._scale;\n    }\n\n    /**\n     * @returns {number} The transform's rotation.\n     */\n    getRotation() {\n        return this._rotation;\n    }\n\n    /**\n     * @returns {Point} The transform's origin offset.\n     */\n    getOriginOffset() {\n        return this._originOffset;\n    }\n}","/**\n * Default fragment shader which handles single colors.\n */\n\nexport const DEFAULT_F = `#version 300 es\n\nprecision mediump float;\n\nuniform vec4 u_color;\n\nout vec4 outColor;\n\nvoid main() {\n  outColor = u_color;\n}\n`;","/**\n * Default vertex shader that handles 2D matricies (3x3 matricies) to screen space.\n */\nexport const DEFAULT_V = `#version 300 es\n\nin vec2 a_position;\n\nuniform mat3 u_matrix;\n\nvoid main() {\n  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);\n}\n`","//base\nimport Updateable from './base/Updateable';\n\n//component\nimport Audio from './component/Audio';\nimport BoxCollider from './component/BoxCollider';\nimport CircleCollider from './component/CircleCollider';\nimport Collider from './component/Collider';\nimport Collider2D from './component/Collider2D';\nimport Component from './component/Component';\nimport Physics from './component/Physics';\nimport Physics2D from './component/Physics2D';\nimport Renderable from './component/Renderable';\nimport Renderable2D from './component/Renderable2D';\nimport RenderableSquare from './component/RenderableSquare';\nimport Transform from './component/Transform';\n\n//const\nimport FragmentShader from './const/FragmentShader';\nimport VertexShader from './const/VertexShader';\n\n//internal\nimport Bounds from './internal/Bounds';\nimport Point from './internal/Point';\n\n//manager\nimport AudioManager from './manager/AudioManager';\nimport DOMManager from './manager/DOMManager';\nimport EngineManager from './manager/EngineManager';\nimport InputManager from './manager/InputManager';\nimport Manager from './manager/Manager';\nimport NetworkManager from './manager/NetworkManager';\nimport UpdateableManager from './manager/UpdateableManager';\nimport PersistentManager from './manager/PersistentManager';\nimport PhysicsManager from './manager/PhysicsManager';\nimport RenderManager from './manager/RenderManager';\nimport SceneManager from './manager/SceneManager';\n\n//object\nimport GameObject from './object/GameObject';\nimport SceneObject from './object/SceneObject';\nimport PersistentObject from './object/PersistentObject';\n\n//prefab\n\n//render\n    //WebGL\n    import Matrix from './render/WebGL/Matrix';\n    import Matrix3 from './render/WebGL/Matrix3';\nimport Camera from './render/Camera';\nimport Light from './render/Light';\nimport Viewport from './render/Viewport';\n\n//scene\nimport Scene from './scene/Scene';\nimport BasicScene from './scene/BasicScene';\n\n//utils\nimport * as MathUtil from './utils/MathUtil';\n\nimport Engine from './Engine';\n\nexport {\n    Updateable,\n    Audio,\n    BoxCollider,\n    CircleCollider,\n    Collider,\n    Collider2D,\n    Component,\n    Physics,\n    Physics2D,\n    Renderable,\n    Renderable2D,\n    RenderableSquare,\n    Transform,\n    FragmentShader,\n    VertexShader,\n    Bounds,\n    Point,\n    AudioManager,\n    DOMManager,\n    EngineManager,\n    InputManager,\n    Manager,\n    NetworkManager,\n    UpdateableManager,\n    PersistentManager,\n    PhysicsManager,\n    RenderManager,\n    SceneManager,\n    GameObject,\n    SceneObject,\n    PersistentObject,\n    Matrix,\n    Matrix3,\n    Camera,\n    Light,\n    Viewport,\n    Scene,\n    BasicScene,\n    MathUtil,\n    Engine,\n};\n\n\n\n","import Point from './Point';\n\n/**\n * Two points which represent a bounding square.\n * \n * TODO: Add z index for 3D.\n */\nexport default class Bounds {\n    /**\n     * \n     * @param {number} x The x position of the bounding box. (x1)\n     * @param {number} y The y position of the bounding box. (y1)\n     * @param {number} w The end x position, or width, of the bounding box. (x2)\n     * @param {number} h The end x position, or height, of the bounding box. (y2)\n     */\n    constructor(x, y, w, h) {\n        this.p1 = new Point(x, y);\n        this.p2 = new Point(w, h);\n    }\n\n    /**\n     * Sets the bounding box to a new position.\n     * \n     * @param {number} x The x position of the bounding box. (x1)\n     * @param {number} y The y position of the bounding box. (y1)\n     * @param {number} w The end x position, or width, of the bounding box. (x2)\n     * @param {number} h The end x position, or height, of the bounding box. (y2)\n     */\n    set(x, y, w, h) {\n        this.p1.set(x, y);\n        this.p2.set(w, h);\n    }\n\n    /**\n     * Checks to see if the point [parameter 0] is within bounds.\n     * \n     * @param {Point} point Point to check within bounds.\n     */\n    isInBounds(point) {\n        return (point.x >= this.p1.x && point.x <= this.p2.x\n                && point.y >= this.p1.y && point.y <= this.p2.y\n                && point.z >= this.p1.z && point.z <= this.p2.z);\n    }\n}","/**\n * A color with r, g, b, a values between 0 and 1.\n * \n * Contains instatiation functions for creating default \n * colors without explicitly defining the values.\n */\nexport default class Color {\n    /**\n     * Builds a color into an array for easy access for WebGL.\n     * \n     * @param {number} r Red value between 0 - 1\n     * @param {number} g Green value between 0 - 1\n     * @param {number} b Blue value between 0 - 1\n     * @param {number} a Alpha value between 0 - 1\n     */\n    constructor(r = 1, g = 0.078, b = 0.576, a = 1) {\n        this.color = [r, g, b, a];\n    }\n\n    /**\n     * \n     * @param {number} r Red value between 0 - 1. Defaults to previous value.\n     * @param {number} g Green value between 0 - 1. Defaults to previous value.\n     * @param {number} b Blue value between 0 - 1. Defaults to previous value.\n     * @param {number} a Alpha value between 0 - 1. Defaults to previous value.\n     */\n    set(r = this.color[0], g = this.color[1], b = this.color[2], a = this.color[3]) {\n        this.color = [r, g, b, a];\n    }\n\n    /**\n     * Returns a new color with the color green. Value: #00FF00 with alpha 1.\n     */\n    static green() {\n        return new Color(0, 1, 0, 1);\n    }\n\n    /**\n     * Returns a new color with the color blue. Value: #0000FF with alpha 1.\n     */\n    static blue() {\n        return new Color(0, 0, 1, 1);\n    }\n\n    /**\n     * Returns a new color with the color red. Value: #FF0000 with alpha 1.\n     */\n    static red() {\n        return new Color(1, 0, 0, 1);\n    }\n\n    /**\n     * Returns a new color with the color pink. Value: #FF1493 with alpha 1.\n     */\n    static pink() {\n        return new Color([1, 0.078, 0.576, 1]);\n    }\n}","/**\n * A point with x, y, z values. It may also be referred to as a Vector.\n */\nexport default class Point {\n    /**\n     * An x, y, z point. Default parameters are set as 0.\n     * \n     * @param {number} x X position of the point.\n     * @param {number} y Y position of the point.\n     * @param {number} z Z position of the point.\n     */\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    \n    /**\n     * Sets the point to a new x, y, z. Previous values are set\n     * as default parameters.\n     * \n     * @param {number} x X position of the point.\n     * @param {number} y Y position of the point.\n     * @param {number} z Z position of the point.\n     */\n    set(x = this.x, y = this.y, z = this.z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}","import Manager from './Manager';\n\nexport class _AudioManager extends Manager {\n    constructor() {\n        super();\n    }\n\n}\n\n/**\n * Singleton reference to the Audio Manager.\n */\nconst AudioManager = new _AudioManager();\nexport default AudioManager;","import Manager from './Manager';\n\n/**\n * Manages the connection between the DOM and the Game & Engine.\n * \n * The DOMManager sets up and holds reference to the DOM elements required to display the game.\n */\nexport class _DOMManager extends Manager {\n    /**\n     * Initializes defaults for the DOMManager to hold once started.\n     */\n    constructor() {\n        super();\n        this.canvas = null;\n        this.GL = null;\n    }\n\n    /**\n     * Loads the canvas & setup for WebGL.\n     */\n    start() {\n        this.loadCanvas();\n    }\n    \n    /**\n     * Loads the canvas & sets up a WebGL2 context to be used by the engine by the id 'game'. If nothing is happening on screen,\n     * ensure that the canvas you are using has this id in its HTML tag.\n     */\n    loadCanvas() {\n        this.canvas = document.getElementById('game');\n        if (this.canvas == null)\n            throw \"Error finding DOM Canvas. The canvas requires an id='game'\";\n        this.GL = this.canvas.getContext('webgl2');\n    }\n}\n\n/**\n * Singleton reference to the DOM Manager.\n */\nconst DOMManager = new _DOMManager();\nexport default DOMManager;","import Manager from './Manager';\nimport RenderManager from './RenderManager';\nimport ProgramManager from './ProgramManager';\nimport SceneManager from './SceneManager';\nimport DOMManager from './DOMManager';\nimport PersistentManager from './PersistentManager';\n\n/**\n *  A singleton & Manager.\n * \n * This class manages the core ECS system & game loop. It calls all other Managers\n * required to start. \n * \n * TODO: This system will be rewritten to allow Manager plugins to be added by the \n * user without editing the Engine.\n */\nexport class _EngineManager extends Manager {\n    constructor() {\n        super();\n        this.MS_PER_FRAME = 30;\n        this.coreUpdateLoopHandle = null;\n        this.hasPaused = false;\n    }\n\n    /**\n     * Called when the Engine should start all systems.\n     * This also includes specific setup code to get the game running, \n     * including setting up the render loop.\n     */\n    start() {\n        //Needs to be first to target the canvas.\n        DOMManager.start();\n        PersistentManager.start();\n        SceneManager.start();\n\n        //Needs to be ahead of RenderManager to init Programs for WebGL.\n        ProgramManager.start();\n        RenderManager.start();\n\n        this.coreUpdateLoopHandle = setInterval(() => {\n            if (!this.hasPaused) {\n                this.update();\n            }\n        }, this.MS_PER_FRAME);\n    }\n\n    /**\n     * The EngineManager sets up a loop on start() to call this function.\n     * Recalling this function will force a game update.\n     */\n    update() {\n        PersistentManager.update();\n        SceneManager.update();\n        RenderManager.update();\n    }\n\n    /**\n     * Ends the Engine by calling all manager end functions.\n     */\n    end() {\n        PersistentManager.end();\n        SceneManager.end();\n        RenderManager.end();\n        clearInterval(this.coreUpdateLoopHandle);\n        DOMManager.end();\n    }\n\n    /**\n     * Pauses the Engine by calling all manager pause functions.\n     */\n    pause() {\n        RenderManager.pause();\n        PersistentManager.pause();\n        SceneManager.pause();\n        this.hasPaused = true;\n    }\n\n    /**\n     * Unpauses the Engine by calling all manager unpause functions.\n     */\n    unpause() {\n        SceneManager.unpause();\n        PersistentManager.unpause();\n        RenderManager.unpause();\n        this.hasPaused = false;\n    }\n}\n\n/**\n * Singleton reference to the Engine Manager.\n */\nconst EngineManager = new _EngineManager();\nexport default EngineManager;","import Manager from './Manager';\n\nexport class _InputManager extends Manager {\n    constructor() {\n        super();\n    }\n\n}\n\n/**\n * Singleton reference to the Input Manager.\n */\nconst InputManager = new _InputManager(); \nexport default InputManager;","/**\n * Baseclass for all Managers.\n * \n * In order for a new Manager to be added to the engine, it must inherit\n * this class and define these functions to be recognized by the Engine.\n * \n * TODO: Finish Plugins in Engine Manager & implement optional function calls on updateables.\n */\n\nexport default class Manager {\n    constructor() {\n\n    }\n    \n    start() {}\n    update() {}\n    end() {}\n    pause() {}\n    unpause() {}\n}","import Manager from './Manager';\n\nexport class _NetworkManager extends Manager {\n    constructor() {\n        super();\n    }\n\n}\n\n/**\n * Singleton reference to the Network Manager.\n */\nconst NetworkManager = new _NetworkManager();\nexport default NetworkManager;","import Manager from './Manager';\n\n/**\n * Manages all Persistent Objects in the Engine. A PersistentObject is a child of \n * GameObject, and sibling of SceneObjects.\n * \n * PersistentObjects exist and update in all scenes, changing scenes will not inturrupt this object.\n */\nexport class _PersistentManager extends Manager {\n    constructor() {\n        super();\n        this.persistentObjects = {};\n    }\n\n    /**\n     * When a PersistentObject is created, it is assigned to the PersistentManager through this function.\n     * The manager will keep reference to the Object and handle Engine events.\n     * \n     * @param {persistentObject} persistentObject A PersistentObject.\n     */\n    registerPersistentObject(persistentObject) {\n        this.persistentObjects[persistentObject.id] = persistentObject;\n        let deregisterCallback = () => {\n            delete this.persistentObjects[persistentObject.id];\n        }\n        return deregisterCallback;\n    }\n\n    /**\n     * Calls update on all Persistent Objects.\n     */\n    update() {\n        let objKeys = Object.keys(this.persistentObjects);\n        for (let i = 0; i < objKeys.length; i++) {\n            this.persistentObjects[objKeys[i]].update();\n        }\n    }\n\n    /**\n     * Calls end on all Persistent Objects.\n     */\n    end() {\n        let objKeys = Object.keys(this.persistentObjects);\n        for (let i = 0; i < objKeys.length; i++) {\n            this.persistentObjects[objKeys[i]].end();\n        }\n    }\n\n    /**\n     * Calls pause on all Persistent Objects.\n     */\n    pause() {\n        let objKeys = Object.keys(this.persistentObjects);\n        for (let i = 0; i < objKeys.length; i++) {\n            this.persistentObjects[objKeys[i]].pause();\n        }\n    }\n\n    /**\n     * Calls unpause on all Persistent Objects.\n     */\n    unpause() {\n        let objKeys = Object.keys(this.persistentObjects);\n        for (let i = 0; i < objKeys.length; i++) {\n            this.persistentObjects[objKeys[i]].unpause();\n        }\n    }\n}\n\n/**\n * Singleton reference to the Persistent Objects Manager.\n */\nconst PersistentManager = new _PersistentManager();\nexport default PersistentManager;","import Manager from './Manager';\n\nexport class _PhysicsManager extends Manager {\n    constructor() {\n        super();\n    }\n\n}\n\n/**\n * Singleton reference to the Physics Manager.\n */\nconst PhysicsManager = new _PhysicsManager();\nexport default PhysicsManager;","import Manager from './Manager';\nimport DOMManager from './DOMManager';\nimport * as VertexShader from '../const/VertexShader';\nimport * as FragmentShader from '../const/FragmentShader';\n\n/**\n * Manages WebGL Programs so that they only need to be created once across the engine\n * allowing multiple objects to still share the same reference.\n * \n * Elliminates the need for the programmer to compile shaders and create programs, and eases \n * on-the-fly Shader compiling.\n */\nexport class _ProgramManager extends Manager {\n    constructor() {\n        super();\n        this.programIDCounter = 0;\n        this.programs = {};\n    }\n\n    /**\n     * Creates default programs for easy reference later on.\n     */\n    start() {\n        this.addProgram('Default', VertexShader.DEFAULT_V, FragmentShader.DEFAULT_F);\n    }\n\n    /**\n     * Returns a Program JSON Object containing the program, name and id.\n     * \n     * @param {string} programKey Name of the program.\n     * \n     * @returns {Program Object} Returns a JSON object with Program data.\n     */\n    getProgram(programKey) {\n        if (this.programs[programKey] == null)\n            throw 'Program does not exist!';\n        return this.programs[programKey];\n    }\n\n    /**\n     * Creates a Program JSON Object and initializes the program and metadata.\n     * The program is added to the programs array.\n     * \n     * @param {string} programName Name of the program.\n     * @param {string} vertexShaderSource Source code of the vertex shader.\n     * @param {string} fragmentShaderSource Source code of the fragment shader.\n     */\n    addProgram(programName, vertexShaderSource, fragmentShaderSource) {\n        this.programs[programName] = {\n            name: programName,\n            id: this.programIDCounter++,\n            program: this._createProgram(vertexShaderSource, fragmentShaderSource),\n        };\n    }\n\n    /**\n     * Creates a WebGL program from a compiled vertex and fragment shader. The program is returned.\n     * \n     * @param {CompiledVertexShader} vertexShader A compiled vertex shader.\n     * @param {CompiledFragmentShader} fragmentShader A compiled fragment shader.\n     * \n     * @returns {Program} A WebGL program. Null if unsuccessful.\n     */\n    _createShadersProgram(vertexShader, fragmentShader) {\n        let program = DOMManager.GL.createProgram();\n        DOMManager.GL.attachShader(program, vertexShader);\n        DOMManager.GL.attachShader(program, fragmentShader);\n        DOMManager.GL.linkProgram(program);\n        let success = DOMManager.GL.getProgramParameter(program, DOMManager.GL.LINK_STATUS);\n        if (success) {\n            return program;\n        }\n\n        console.error(DOMManager.GL.getProgramInfoLog(program));\n        DOMManager.GL.deleteProgram(program);\n        return null;\n    }\n\n    /**\n     * Creates a shader of either Vertex or Fragment type and returns the compiled version.\n     * \n     * @param {GLShaderType} type A GL shader type of either VERTEX_SHADER or FRAGMENT_SHADER.\n     * @param {string} source Source code for the shader type.\n     * \n     * @returns {CompiledShader} A compiled shader. Null if unsuccessful.\n     */\n    _createShader(type, source) {\n        let shader = DOMManager.GL.createShader(type);\n        DOMManager.GL.shaderSource(shader, source);\n        DOMManager.GL.compileShader(shader);\n        let success = DOMManager.GL.getShaderParameter(shader, DOMManager.GL.COMPILE_STATUS);\n        if (success) {\n            return shader;\n        }\n\n        console.error(DOMManager.GL.getShaderInfoLog(shader));\n        DOMManager.GL.deleteShader(shader);\n        return null;\n    }\n\n    /**\n     * Compiles the vertex shader and fragment shader and returns a WebGL program.\n     * \n     * @param {string} vertexShaderSource Source code for a vertex shader.\n     * @param {string} fragmentShaderSource Source code for a fragment shader.\n     * \n     * @returns {Program} A program compiled from the two shader sources.\n     */\n    _createProgram(vertexShaderSource, fragmentShaderSource) {\n        let vertexShader = this._createShader(DOMManager.GL.VERTEX_SHADER, vertexShaderSource);\n        let fragmentShader = this._createShader(DOMManager.GL.FRAGMENT_SHADER, fragmentShaderSource);\n\n        return this._createShadersProgram(vertexShader, fragmentShader);\n    }\n}\n\n/**\n * Singleton reference to the WebGL Program Manager.\n */\nconst ProgramManager = new _ProgramManager();\nexport default ProgramManager;","import Manager from './Manager';\nimport DOMManager from './DOMManager';\nimport ProgramManager from './ProgramManager';\nimport SceneManager from './SceneManager';\nimport * as VertexShader from '../const/VertexShader';\nimport * as FragmentShader from '../const/FragmentShader';\nimport Matrix3 from '../render/WebGL/Matrix3';\n\nexport class _RenderManager extends Manager {\n    constructor() {\n        super();\n        this.GL = null;\n        this.currentProgram = null;\n    }\n\n    /**\n     * Initial setup on GL rendering. \n     */\n    start() {\n        this.GL = DOMManager.GL;\n\n        this._updateProgram(ProgramManager.getProgram('Default'));\n        \n        this.positionAttributeLocation = this.GL.getAttribLocation(this.currentProgram.program, \"a_position\");\n        this.colorLocation = this.GL.getUniformLocation(this.currentProgram.program, \"u_color\");\n        this.matrixLocation = this.GL.getUniformLocation(this.currentProgram.program, \"u_matrix\");\n\n        let positionBuffer = this.GL.createBuffer();\n\n        this.GL.bindBuffer(this.GL.ARRAY_BUFFER, positionBuffer);\n\n        this.GL.bufferData(this.GL.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), this.GL.STATIC_DRAW);\n\n        this.vao = this.GL.createVertexArray();\n\n        this.GL.bindVertexArray(this.vao);\n\n        this.GL.enableVertexAttribArray(this.positionAttributeLocation);\n\n        let size = 2;\n        let type = this.GL.FLOAT;\n        let normalize = false;\n        let stride = 0;\n        let vertexOffset = 0;\n        this.GL.vertexAttribPointer(this.positionAttributeLocation, size, type, normalize, stride, vertexOffset);\n    }\n\n    /**\n     * Checks if the program for the next object to draw must be changed.\n     * If it does, it will change WebGL programs.\n     * \n     * @param {ProgramObject} program A program object returned from ProgramManager.getProgram()\n     */\n    _updateProgram(program) {\n        if (this.currentProgram == null || this.currentProgram.id != program.id) {\n            console.info('switching programs')\n            this.GL.useProgram(program.program);\n            this.currentProgram = program;\n        }\n    }\n\n    /**\n     * Update function for updating all renderable objects in each viewport in the current scene.\n     */\n    update() {\n        this.GL.clearColor(0, 0, 0, 0);\n    \n        this.GL.clear(this.GL.COLOR_BUFFER_BIT | this.GL.DEPTH_BUFFER_BIT);\n\n        let viewports = SceneManager.getCurrentScene().viewports;\n\n        for (let vi = 0; vi < viewports.length; vi++) {\n            let viewport = viewports[vi];\n\n            let viewPortWidth = viewport.bounds.p2.x - viewport.bounds.p1.x;\n            let viewPortHeight = viewport.bounds.p2.y - viewport.bounds.p1.y;\n\n            this.GL.viewport(viewport.bounds.p1.x, viewport.bounds.p1.y, viewport.bounds.p2.x, viewport.bounds.p2.y);\n\n            //setup camera from viewport\n\n            let renderables = viewport.renderables;\n            let renderableKeys = Object.keys(renderables);\n            for (let ri = 0; ri < renderableKeys.length; ri++) {\n                let renderable = renderables[renderableKeys[ri]];\n\n                this._updateProgram(renderable.program);\n\n                this.GL.uniform4fv(this.colorLocation, renderable.color.color);\n                this.GL.uniformMatrix3fv(this.matrixLocation, false, Matrix3.projection(viewPortWidth, viewPortHeight).multiply(renderable.getMatrix()).m);\n\n\n                this.GL.drawArrays(renderable.primitiveType, 0, renderable.primitiveCount);\n            }\n        }\n    }\n}\n\n/**\n * Singleton reference to the Rendering Manager.\n */\nconst RenderManager = new _RenderManager();\nexport default RenderManager;","import Manager from './Manager';\nimport GameObject from '../object/GameObject';\n\n/**\n * A manager which manages all scenes and passes commands to the current scene.\n * \n * Manages scenes on a stack, pausing scenes below them (stopping rendering), and managing\n * the top scene for triggering updates on all objects on the scene.\n * \n * GameObjects, components, or anything else can use the SceneManager to reference the\n * current active scene. There are also wrapper functions for passing SceneObjects and\n * Viewports to the current scene for registration with that scene.\n */\nexport class _SceneManager extends Manager {\n    constructor() {\n        super();\n        this.scenes = [];\n    }\n\n    /**\n     * Adds a SceneObject to the current scene on the stack. The scene will hold \n     * reference and manage the SceneObject.\n     * \n     * @param {SceneObject} sceneObject The SceneObject that is being registered.\n     */\n    registerSceneObject(sceneObject) {\n        let scene = this.getCurrentScene();\n        if (scene != null)\n            return scene.registerSceneObject(sceneObject);\n    }\n\n    /**\n     * Addsa viewport to the current scene on the stack. The scene will hold reference\n     * to the viewport.\n     * \n     * @param {viewport} viewport The Viewport that is being registered.\n     */\n    registerViewport(viewport) {\n        let scene = this.getCurrentScene();\n        if (scene != null)\n            scene.registerViewport(viewport);\n    }\n\n    /**\n     * Gets the current scene on the stack. This scene will be the one currently\n     * used in the update loop.\n     */\n    getCurrentScene() {\n        if (this.scenes.length > 0)\n            return this.scenes[this.scenes.length - 1];\n        return null;\n    }\n\n    /**\n     * Starts the current scene on the stack.\n     */\n    start() {\n        if (this.scenes.length > 0) {\n            this.scenes[this.scenes.length - 1].start();\n        }\n    }\n\n    /**\n     * Updates the current scene and all SceneObjects that are assigned to that\n     * scene.\n     */\n    update() {\n        let scene = this.getCurrentScene();\n        if (scene != null) {\n            scene.update();\n            for (let i = 0; i < scene.sceneObjects.length; i++) {\n                scene.sceneObjects[i].update();\n            }\n        }\n    }\n\n    /**\n     * Ends all scenes, starting from the top & poping each scene off the stack as it goes.\n     */\n    end() {\n        while (this.scenes.length > 0) {\n            this.scenes[this.scenes.length - 1].pop().end();\n        }\n    }\n\n    /**\n     * Pauses the current scene.\n     */\n    pause() {\n        if (this.scenes.length > 0)\n            this.scenes[this.scenes.length - 1].pause();\n    }\n    \n    /**\n     * Unpauses the current scene.\n     */\n    unpause() {\n        if (this.scenes.length > 0)\n            this.scenes[this.scenes.length - 1].unpause();\n    }\n\n    /**\n     * Adds the new scene to the top of the stack, pausing the current\n     * scene first.\n     * \n     * @param {Scene} scene The new scene.\n     */\n    addScene(scene) {\n        this.pause();\n        this.scenes.push(scene);\n    }\n\n    /**\n     * Removes the top scene from the stack, calls its end() function,\n     * and unpauses the scene below it.\n     */\n    removeScene() {\n        this.scenes.pop().end();\n        this.unpause();\n    }\n}\n\n/**\n * Singleton reference to the Scene Manager.\n */\nconst SceneManager = new _SceneManager();\nexport default SceneManager;","import Manager from './Manager';\n\n/**\n * Singleton manager that manages all Updateable Objects. All updateable objects are given a global game\n * ID (number) which can be used to distinguish it.\n * \n * Any object that descends from Updateable will have an ID.\n */\nexport class _UpdateableManager extends Manager {\n    /**\n     * Constructor for UpdateableManager. Holds the static ID counter.\n     */\n    constructor() {\n        super();\n        this.updateableIDCounter = 0;\n    }\n\n    /**\n     * Gives an ID and a way to unsubscribe from the Updateable binding with the manager.\n     * \n     * Since the UpdateableManager does nothing to bind the Updateable to the manager, there is no code in the callback\n     * assigned. However, the pattern is there to outline a default.\n     * \n     * @param {Updateable} updateable The updateable to be registered.\n     */\n    registerUpdateable(updateable) {\n        updateable.id = this.updateableIDCounter++;\n        let deregisterCallback = () => {}\n        return deregisterCallback;\n    }\n}\n\n/**\n * Singleton reference to the Object Manager.\n */\nconst UpdateableManager = new _UpdateableManager();\nexport default UpdateableManager;","import Updateable from '../base/Updateable';\nimport Component from '../component/Component';\nimport Transform from '../component/Transform';\n\n/**\n * Baseclass GameObject which derives from Updateable.\n * \n * Do not derive this class directly! GameObjects are not managed until they are assigned to a manager.\n * Instead, derive SceneObject or PersistentObject to create objects that exist the scope of a scene, or the scope of the game.\n * \n * All objects that should exist in the game screen should derive this. \n */\nexport default class GameObject extends Updateable {\n    /**\n     * Default position, size and rotation of the Object.\n     * \n     * @param {Point} position A point of creation in the world.\n     * @param {Point} size A point representing scale of the object.\n     * @param {number} rotation A number representing angular rotation (in degrees).\n     */\n    constructor(position = new Point(0, 0, 0), size = new Point(32, 32, 1), rotation = 0) {\n        super();\n        this.className = 'GameObject';\n\n        this.components = {};\n        this.addComponent(new Transform(position, size, rotation));\n        this.transform = this.getComponent(\"Transform\");\n    }\n\n    /**\n     * Adds a component to this game object, and keeps reference to it.\n     * GameObjects will handle their components as they are added to the object.\n     * \n     * @param {Component} component The component assigned to this object.\n     */\n    addComponent(component) {\n        if (this.components[component.className] == null) {\n            this.components[component.className] = [];\n        }\n        if (component.isUnique && this.components[component.className].length > 0) {\n            throw 'There is already a unique component of type ' + component.className + ' on this GameObject!';\n            return false;\n        }\n        this.components[component.className].push(component);\n        component.gameObject = this;\n        component.onAddComponent();\n        return true;\n    }\n\n    /**\n     * Removes a single component from this GameObject by ID.\n     * \n     * @param {number} componentID Id of the component to remove.\n     */\n    removeComponent(componentID) {\n        if (this.components[component.className] == null)\n            return false;\n        for (let i = 0; i < this.components[component.className].length; i++) {\n            if (this.components[component.className][i].id === componentID) {\n                this.components[component.className][i].end();\n                this.components[component.className].splice(i, 1);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Removes all Components of the named type.\n     * \n     * @param {string} componentName The name of the components to clear.\n     */\n    removeComponents(componentName) {\n        if (this.components[componentName] == null)\n            return false;\n        for (let i = 0; i < this.components[componentName].length; i++) {\n            this.components[componentName][i].end();\n            this.components[componentName].splice(i, 1);\n        }\n        return true;\n    }\n\n    /**\n     * Removes all components except for the Transform component.\n     */\n    removeAllComponents() {\n        let compTypes = Object.keys(this.components);\n        for (let i = 0; i < compTypes.length; i++) {\n            let thisCompType = compTypes[i];\n            if (thisCompType === 'Transform')\n                continue;\n            for (let ii = 0; ii < this.components[thisCompType].length; ii++) {\n                this.components[thisCompType][ii].end();\n                this.components[thisCompType].splice(ii, 1);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a boolean on if there is a component of type {componentName}.\n     * \n     * @param {string} componentName Name of the component type to search for.\n     * \n     * @returns {boolean} true if there is at least one component of this type.\n     */\n    hasComponent(componentName) {\n        if (this.components[componentName] == null) {\n            return false;\n        }\n        return this.components[componentName].length > 0;\n    }\n\n    /**\n     * Returns a component of type {componentName}. The second parameter can determine which \n     * Component of that type to return if there are more than 1. \n     * \n     * @param {string} componentName Name of the component type to return.\n     * @param {*} index Index of the component to get. Defaults to first component.\n     */\n    getComponent(componentName, index = 0) {\n        if (this.components[componentName] == null) {\n            return null;\n        }\n        return this.components[componentName][index];\n    }\n\n    /**\n     * Updates all components on this GameObject.\n     */\n    updateComponents() {\n        let compTypes = Object.keys(this.components);\n        for (let i = 0; i < compTypes.length; i++) {\n            let thisCompType = compTypes[i];\n            for (let ii = 0; ii < this.components[thisCompType].length; ii++) {\n                this.components[thisCompType][ii].update();\n            }\n        }\n    }\n    \n    /**\n     * Rewritten postStartUpdate() functions which is originally defined in Updateable.\n     * The GameObject adds a pre and post update function, and respective overrideable callbacks\n     * (onPreUpdate and onPostUpdate).\n     */\n    postStartUpdate() {\n        if (this.hasPaused)\n            return;\n        \n        this.preUpdate();\n        this.onUpdate();\n        this.updateComponents();\n        this.postUpdate();\n    }\n\n    /**\n     * Called by the GameObject before an update to do default calls for preUpdating. Afterwards it\n     * calls the overrideable function, onPreUpdate.\n     */\n    preUpdate() {\n        this.onPreUpdate();\n    }\n\n    /**\n     * Called by the GameObject after an update to do default calls for postUpdating. Afterwards it\n     * calls the overrideable function, onPostUpdate.\n     */\n    postUpdate() {\n        this.onPostUpdate();\n    }\n\n    /**\n     * Override for Pre Update functionality.\n     */\n    onPreUpdate() {}\n\n    /**\n     * Override for Post Update functionality.\n     */\n    onPostUpdate() {}\n}","import GameObject from \"./GameObject\";\nimport PersistentManager from \"../manager/PersistentManager\";\n\n/**\n * A GameObject which exists across scenes. \n * \n * Objects which derive PersistentObjects do not belong to any one scene. \n * If the derived object is intended to be rendered cross scene, the renderable component's\n * viewports must be reassigned on scene changes.\n */\nexport default class PersistentObject extends GameObject {\n    /**\n     * Default position, size and rotation of the Object.\n     * \n     * @param {Point} position A point of creation in the world.\n     * @param {Point} size A point representing scale of the object.\n     * @param {number} rotation A number representing angular rotation (in degrees).\n     */\n    constructor(position = new Point(0, 0, 0), size = new Point(32, 32, 1), rotation = 0) {\n        super(position, size, rotation);\n        this.deregister = PersistentManager.registerSceneObject(this);\n    }\n}","import GameObject from \"./GameObject\";\nimport SceneManager from '../manager/SceneManager';\n\n/**\n * A GameObject which exists only on the current active scene.\n * When this object is instantiated, it registers with the current active scene\n * through the SceneManager.\n * \n */\nexport default class SceneObject extends GameObject {\n    /**\n     * Default position, size and rotation of the Object.\n     * \n     * @param {Point} position A point of creation in the world.\n     * @param {Point} size A point representing scale of the object.\n     * @param {number} rotation A number representing angular rotation (in degrees).\n     */\n    constructor(position = new Point(0, 0, 0), size = new Point(32, 32, 1), rotation = 0) {\n        super(position, size, rotation);\n        this.deregister = SceneManager.registerSceneObject(this);\n    }\n}","import SceneManager from '../manager/SceneManager';\nimport DOMManager from '../manager/DOMManager';\nimport Updateable from '../base/Updateable';\nimport Bounds from '../internal/Bounds';\n\n/**\n * A viewport is a display port on the game canvas. Each scene can have multiple\n * viewports and renderable objects are assigned to the ones they want to be drawn on.\n * \n * Viewports contain lighting and cameras.\n * \n * GameObjects and their components exist across all viewports, it is up to the programmer\n * to specify the viewports to render to.\n * \n * Examples on when to use viewports: \n * - UI\n * - Minimaps\n * - Different views\n * \n * TODO: An object of keys represented by 'z' indexes to store all \n * renderable objects in render order.\n */\nexport default class Viewport extends Updateable {\n    constructor(x, y, w, h) {\n        super();\n        this.bounds = new Bounds(x, y, w, h);\n\n        this.renderables = {};\n    }\n\n    /**\n     * Register an Updateable component with this viewport for drawing.\n     * \n     * @param {Renderable} renderable Renderable component to register.\n     */\n    registerRenderableComponent(renderable) {\n        this.renderables[renderable.id] = renderable;\n        let deregisterCallback = () => {\n            delete this.renderables[renderable.id];\n        }\n        return deregisterCallback;\n    }\n}","\n/**\n * Baseclass for a Matrix. Use Matrix3 or Matrix4 for 2D and 3D matrix math.\n */\nexport default class Matrix {\n\n    setPosition(x, y) {}\n\n    setScale(scaleX, scaleY) {}\n\n    setRotation(rotationDegree) {}\n\n    copy() {}\n\n    add(m) {}\n\n    multiply(m) {}\n}","import * as MathUtil from '../../utils/MathUtil';\nimport Matrix from './Matrix';\n\n\nexport default class Matrix3 extends Matrix {\n    constructor(data = [1,0,0,0,1,0,0,0,1]) {\n        super();\n        //default x = 0, y = 0, scaleXY = 1, rotation = 0\n        this.m = data;\n        return this;\n    }\n\n    /**\n     * Sets the translation positions of the matrix with x, y points. This overwrites the values and \n     * does not adjust the parameters to work relative to the rest of the matrix values.\n     * \n     * @param {number} x X position.\n     * @param {number} y Y position.\n     */\n    setPosition(x, y) {\n        this.m[6] = x;\n        this.m[7] = y;\n    }\n\n    /**\n     * Sets the scale values of the matrix with w, h values. This overwrites the values and \n     * does not adjust the parameters to work relative to the rest of the matrix values.\n     * \n     * @param {number} x X scale.\n     * @param {number} y Y scale.\n     */\n    setScale(x, y) {\n        this.m[0] = x;\n        this.m[4] = y;\n    }\n\n    /**\n     * Sets the matrix rotation values to rotate an object around the z axis. This overwrites the values and \n     * does not adjust the parameters to work relative to the rest of the matrix values.\n     * \n     * @param {number} rotationDegree \n     */\n    setRotation(rotationDegree) {\n        let rad = MathUtil.degToRad(rotationDegree);\n        let c = Math.cos(rad);\n        let s = Math.sin(rad);\n        this.m[0] = c;\n        this.m[1] = -s;\n        this.m[3] = s;\n        this.m[4] = c;\n    }\n\n    /**\n     * Makes a copy of the matrix3. This is a static function and can be called\n     * from Matrix3 prototype.\n     * \n     * @param {Matrix3} matrix The matrix3 to copy.\n     */\n    static copy(matrix) {\n        return new Matrix3(matrix.m.slice(0, matrix.m.length));\n    }\n\n    /**\n     * Adds a matrix to this matrix.\n     * \n     * @param {Matrix3} m3 The matrix to add to this matrix.\n     */\n    add(m3) {\n        throw 'unimplemented';\n    }\n\n    /**\n     * Static function which returns a projection matrix converting the\n     * top left coordinates to 0, 0, and bottom right to w, h.\n     * \n     * (Converted from -1, -1 top left to 1, 1 bottom right.)\n     * \n     * @param {number} w Width of the projection.\n     * @param {number} h Height of the projection.\n     */\n    static projection(w, h) {\n        return new Matrix3([\n        2 / w, 0, 0,\n        0, -2 / h, 0,\n        -1, 1, 1]);\n    }\n\n    /**\n     * Multiplies a matrix into this matrix.\n     * \n     * @param {Matrix3} m3 The matrix to multiply to this matrix.\n     */\n    multiply(m3) {\n        let mat = new Matrix3();\n        mat.m[0] = (this.m[0] * m3.m[0]) + (this.m[3] * m3.m[1]) + (this.m[6] * m3.m[2]);\n        mat.m[1] = (this.m[1] * m3.m[0]) + (this.m[4] * m3.m[1]) + (this.m[7] * m3.m[2]);\n        mat.m[2] = (this.m[2] * m3.m[0]) + (this.m[5] * m3.m[1]) + (this.m[8] * m3.m[2]);\n\n        mat.m[3] = (this.m[0] * m3.m[3]) + (this.m[3] * m3.m[4]) + (this.m[6] * m3.m[5]);\n        mat.m[4] = (this.m[1] * m3.m[3]) + (this.m[4] * m3.m[4]) + (this.m[7] * m3.m[5]);\n        mat.m[5] = (this.m[2] * m3.m[3]) + (this.m[5] * m3.m[4]) + (this.m[8] * m3.m[5]);\n\n        mat.m[6] = (this.m[0] * m3.m[6]) + (this.m[3] * m3.m[7]) + (this.m[6] * m3.m[8]);\n        mat.m[7] = (this.m[1] * m3.m[6]) + (this.m[4] * m3.m[7]) + (this.m[7] * m3.m[8]);\n        mat.m[8] = (this.m[2] * m3.m[6]) + (this.m[5] * m3.m[7]) + (this.m[8] * m3.m[8]);\n        return mat;\n    }\n}","import Scene from './Scene';\nimport { Viewport } from '../entry';\nimport DOMManager from '../manager/DOMManager';\n\n/**\n * A basic representation of a working scene. Scenes need a viewport to give Renderable\n * components a place to be viewed by the RenderManager.\n * \n * This scene only contains one viewport which takes up the size of the canvas element.\n */\nexport default class BasicScene extends Scene {\n    constructor() {\n        super();\n        this.registerViewport(new Viewport(0, 0, DOMManager.canvas.width, DOMManager.canvas.height));\n    }\n}","import Updateable from '../base/Updateable';\nimport { SceneObject } from '../entry';\n\n/**\n * Baseclass for all scenes. When creating a new scene, it should inherit this\n * class. \n * Scenes keep track of their scene objects and viewports. The scene baseclass has\n * functions for registering these with the scene.\n */\nexport default class Scene extends Updateable {\n\n    /**\n     * Builds the SceneObjects and Viewports list.\n     */\n    constructor() {\n        super();\n        this.sceneObjects = [];\n        this.viewports = [];\n    }\n\n    /**\n     * When a SceneObject is created, it is routed through the SceneManager to the current\n     * active scene to this function. The SceneObject will register with the scene to be referenced\n     * on update/pause/destruct calls on a scene specific basis.\n     * \n     * @param {SceneObject} sceneObject A SceneObject to register.\n     */\n    registerSceneObject(sceneObject) {\n        this.sceneObjects.push(sceneObject);\n        let deregisterCallback = () => {\n            for (let i = 0; i < this.sceneObjects.length; i++) {\n                if (this.sceneObjects[i].id ==sceneObject.id)\n                    this.sceneObjects.splice(i, 1);\n                    return;\n            }\n        }\n        return deregisterCallback;\n    }\n\n    /**\n     * Registers a Renderable component with the viewport, by index.\n     * \n     * @param {Renderable} renderable A Renderable to register to the viewport.\n     * @param {number} viewportIndex The index of the viewport.\n     */\n    registerRenderableComponent(renderable, viewportIndex) {\n        if (this.viewports.length > viewportIndex)\n            return this.viewports[viewportIndex].registerRenderableComponent(renderable);\n        else {\n            throw \"This viewport doesn't exist on this scene!\";\n        }\n    }\n\n    /**\n     * When a Viewport is created, it is routed through the SceneManager to the current\n     * active scene to this function. The Viewport will register with the scene to be referenced\n     * by the RenderManager and assigned to by Renderables.\n     * \n     * @param {Viewport} viewport A Viewport to register.\n     */\n    registerViewport(viewport) {\n        this.viewports.push(viewport);\n        this.viewportIndex = this.viewports.length - 1;\n        let deregisterCallback = () => {\n            for (let i = 0; i < this.viewports.length; i++) {\n                if (this.viewports[i].id === viewport.id) {\n                    this.viewports[i].splice(i, 1);\n                    return;\n                }\n            }\n        }\n        return deregisterCallback;\n    }\n}","/**\n * Converts degrees to radians.\n * \n * @param {number} deg A number in degrees.\n */\nexport const degToRad = (deg) => {\n    return (deg / 180) * Math.PI;\n}\n\n/**\n * Converts radians to degress.\n * \n * @param {number} rad A number in radians.\n */\nexport const radToDeg = (rad) => {\n    return (deg / Math.PI) * 180;\n}","import {Component, Point, SceneManager, Bounds} from 'seed-engine';\n\nexport default class RandomMovement extends Component {\n    /**\n     * Creates a new direction point (vector) to begin moving as.\n     */\n    constructor() {\n        super(true);\n        this.className = 'RandomMovement';\n        this.direction = new Point(Math.random() * 20 - 10, Math.random() * 20 - 10);\n        this.sceneViewportBounds = new Bounds();\n    }\n\n    /**\n     * Gets the bounds of the viewport once. If your viewports aren't going to be changing,\n     * this saves wasted time spent getting the bounds each update.\n     */\n    onStart() {\n        this.sceneViewportBounds = SceneManager.getCurrentScene().viewports[0].bounds;\n    }\n\n    /**\n     * Moves in the direction of this.direction until it comes\n     * in contact to one of the edges of the viewport.\n     */\n    onUpdate() {\n        let transform = this.gameObject.transform;\n        let position = transform.getPosition();\n        let size = transform.getScale();\n        if (position.x - size.x / 2 + this.direction.x <= 0)\n            this.direction.x = Math.abs(this.direction.x);\n        if (position.x + size.x / 2 + this.direction.x >= this.sceneViewportBounds.p2.x)\n            this.direction.x = -Math.abs(this.direction.x);\n        if (position.y - size.y / 2 + this.direction.y <= 0)\n            this.direction.y = Math.abs(this.direction.y);\n        if (position.y + size.y / 2 + this.direction.y >= this.sceneViewportBounds.p2.y)\n            this.direction.y = -Math.abs(this.direction.y);\n        transform.translate(this.direction.x, this.direction.y);\n    }\n}","import {Engine, BasicScene, SceneManager} from 'seed-engine';\nimport MainScene from './scene/MainScene';\n\n/**\n * Example entry class for a game. Defines a class then starts creates one underneath.\n * \n * Ensure to call Engine.start() before doing anything.\n */\nexport class Game {\n    constructor() {\n    }\n\n    /**\n     * Starts the engine loop, then adds a new scene to it.\n     */\n    start() {\n        Engine.start();\n        SceneManager.addScene(new MainScene());\n    }\n}\n\nnew Game().start();","import {SceneObject, Renderable2D, Point, DOMManager} from 'seed-engine';\nimport RandomMovement from '../component/RandomMovement';\n\n/**\n * An example class of how a SceneObject should be written. This player doesn't actually have any way\n * of being a \"player\" yet, as there is no input reading.\n */\nexport default class Player extends SceneObject {\n    /**\n     * Defines a random position to start, and adds a Renderable Component of random color, and another component, RandomMovement.\n     */\n    constructor() {\n        super(new Point(100 + (Math.random() * DOMManager.GL.canvas.width - 100), 100 + (Math.random() * DOMManager.GL.canvas.height - 100)), new Point(50, 50, 50), 0);\n        let renderable = new Renderable2D();\n        this.addComponent(renderable);\n        renderable.addToViewport(0);\n        renderable.color.set(Math.random(), Math.random(), Math.random());\n\n        this.addComponent(new RandomMovement());\n        this.transform.centerOrigin();\n    }\n\n    /**\n     * Called on the first update this Object has existed.\n     */\n    onStart() {\n    }\n\n    /**\n     * Called every update once the start() has been called.\n     */\n    onUpdate() {\n    }\n}","import {BasicScene} from 'seed-engine';\nimport Player from '../object/Player';\nimport RandomMovement from '../component/RandomMovement';\n\n/**\n * The main scene of the game, containing one fullscreen view.\n */\nexport default class MainScene extends BasicScene {\n    constructor() {\n        super();\n    }\n\n    /**\n     * When this scene is started, it creates 20 players.\n     */\n    onStart() {\n        for (let i = 0; i < 20; i++) {\n            new Player();\n        }\n    }\n\n    /**\n     * If the scene wanted to do updates that wasn't game-scope, and isn't object-scope, it should be done here.\n     */\n    onUpdate() {\n    }\n\n    /**\n     * Called when the game is ending.\n     */\n    onEnd() {\n\n    }\n}"],"sourceRoot":""}